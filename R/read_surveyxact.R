#' Import Data Generated by SurveyXact
#'
#' First export the data from SurveyXact either as Excel or a set of CSV-files
#'     in European format (semicolon-sep). Then import using this function while
#'     setting variable labels and value labels automatically. Can then use
#'     labelled-package or other functions in this package for
#'     further processing.
#'
#' @param filepath A character string with a path to an Excel file, or a character vector with paths to the dataset.csv, structure.csv and labels.csv-files.
#' @param remove_whitespace Logical, default is FALSE. Whether to remove
#'     leading and ending whitespace from all files.
#' @param col_select unquoted columns to be selected. Takes tidyselect syntax.
#'
#' @return tibble
#' @importFrom purrr map reduce
#' @importFrom rlang abort set_names .data inform warn
#' @importFrom readxl excel_sheets read_excel
#' @importFrom utils read.delim
#' @importFrom vctrs vec_assert
#' @importFrom labelled set_variable_labels set_value_labels val_labels
#' @importFrom dplyr tibble select enquo
#' @importFrom tidyselect eval_select
#' @export
#'
#' @examples
# ex_survey2_xlsx <-
#       read_surveyxact(filepath =
#                       system.file("extdata", "ex_survey2.xlsx",
#                       package = "readSX", mustWork = TRUE))
#' dataset <- system.file("extdata", "ex_survey2_tab_utf16", "dataset.csv",
#'                       package = "readSX", mustWork = TRUE)
#' labels <- system.file("extdata", "ex_survey2_tab_utf16", "labels.csv",
#'   					  package = "readSX", mustWork = TRUE)
#' structure <- system.file("extdata", "ex_survey2_tab_utf16", "structure.csv",
#'  						 package = "readSX", mustWork = TRUE)
#' ex_survey2_tab_utf16 <-
#' 	read_surveyxact(filepath=c(dataset = dataset,
#'							   labels = labels,
#'							   structure = structure))
read_surveyxact <-
	function(filepath=c(dataset="dataset.csv",
						structure ="structure.csv",
						labels="labels.csv"),
			 remove_whitespace=FALSE, col_select=NULL) {

		vctrs::vec_assert(x = filepath, ptype = character())
		if(length(filepath)==1L && grepl(".xlsx", filepath)) {
			df_data <- grep("Dataset\\(*1*\\)*.*", readxl::excel_sheets(filepath), value = TRUE)
			df_data <- purrr::map(.x = df_data,
								  .f = ~readxl::read_excel(path = filepath, guess_max = 10000L,
								  						 sheet=.x, trim_ws = remove_whitespace))
			df_data <- purrr::reduce(df_data, cbind)
			df_data <- as.data.frame(df_data)

			df_vars <-  readxl::read_excel(path = filepath, sheet="Structure",
										   trim_ws = remove_whitespace)
			df_vars <- as.data.frame(df_vars)
			df_labels <- suppressMessages(readxl::read_excel(path = filepath,
															 sheet="Labels", col_names = FALSE,
															 trim_ws = remove_whitespace))
			df_labels <- as.data.frame(df_labels)
			colnames(df_labels) <- c("variableName", "value", "valueLabel")
		} else if(length(filepath)==3L && all(grepl(".csv", filepath))) {

			if(all(tolower(names(filepath)) %in% c("dataset", "structure", "labels"))) {

				df_data <- filepath[names(filepath)=="dataset"]
				df_vars <- filepath[names(filepath)=="structure"]
				df_labels <- filepath[names(filepath)=="labels"]

			} else if(is.null(names(filepath))) {
				rlang::inform("`filepath` is an unnamed character vector, guessing which is which from filenames.")
				df_data <- grep("dataset.csv", filepath, fixed = TRUE, value = TRUE)
				df_vars <- grep("structure.csv", filepath, fixed = TRUE, value = TRUE)
				df_labels <- grep("labels.csv", filepath, fixed = TRUE, value = TRUE)
			}

			df_data <-
				utils::read.delim(file = df_data,
								  header = TRUE, sep = "\t", quote = '\"',
								  row.names = NULL, stringsAsFactors = FALSE,
								  fileEncoding = "utf16", na.strings = c(NA, ""),
								  strip.white = remove_whitespace)
			df_vars <-
				suppressWarnings(
					utils::read.delim(file = df_vars,
								  header = TRUE, sep = "\t", quote = '\"',
								  row.names = NULL, stringsAsFactors = FALSE,
								  fileEncoding = "utf16", na.strings = c(NA, ""),
								  strip.white = remove_whitespace,
								  col.names = c("questionName","variableName","questionType",
								  			  "subType","questionText","choiceValue","choiceText", "remove"))
				)
			df_vars$remove <- NULL

			df_labels <-
				utils::read.delim(file = df_labels,
								  header = FALSE, sep = "\t", quote = '\"',
								  row.names = NULL, stringsAsFactors = FALSE,
								  fileEncoding = "utf16", na.strings = c(NA, ""),
								  strip.white = remove_whitespace,
								  col.names = c("variableName", "value", "valueLabel"))

		} else rlang::abort(c("Invalid filepath:",
							  i="`filepath` must be either a string pointing to an xlsx-file, or",
							  i="a named character vector of length 3 pointing to three CSV-files dataset.csv, structure.csv and labels.csv.",
							  x=paste0("`filepath` is currently a ", class(filepath)[1], " of length ", paste0(length(filepath), collapse=","))))

		if(any(!c("variableName", "questionText") %in% colnames(df_vars))) {
			rlang::abort(c(x="Could not find columns variableName and questionText in Structure"))
		}
		if(any(!c("variableName", "value", "valueLabel") %in% colnames(df_labels))) {
			rlang::abort(c(x="Could not find columns c(variableName, value, valueLabel) in Labels"))
		}

		for(col in names(df_data)) {
			if(is.integer(df_data[[col]]) || is.logical(df_data[[col]])) df_data[[col]] <- as.numeric(df_data[[col]])
			if(is.numeric(df_data[[col]]) && suppressWarnings(max(nchar(df_data[[col]]), na.rm = TRUE) > 8)) {
				df_data[[col]] <- as.character(df_data[[col]]) # Fixes setting in read_excel that allows big integer to be character
			}
		}


		df_vars[["questionText"]] <- trimws(x = df_vars[["questionText"]])
		df_vars[["choiceText"]] <- trimws(x = df_vars[["choiceText"]])
		df_labels[["valueLabel"]] <- trimws(x = df_labels[["valueLabel"]])

		df_vars[["questionText"]] <- ifelse(test = df_vars[["subType"]] == "Multiple",
											yes = paste(df_vars[["questionText"]], df_vars[["choiceText"]], sep=" - "),
											no = df_vars[["questionText"]])

		df_vars <- rlang::set_names(x = df_vars[["questionText"]], nm = df_vars[["variableName"]])
		df_vars <- as.list(df_vars)
		df_labels <- split(x = df_labels, f = df_labels[["variableName"]])
		df_labels <- purrr::map(.x = df_labels, .f = function(x) {
			rlang::set_names(x = x$value, nm = x$valueLabel)
		})

		df_data <- labelled::set_variable_labels(df_data, .labels = df_vars, .strict = FALSE)



		unmatched <- c()
		for(i in names(df_labels)) {
			if(i %in% colnames(df_data)) {
				labelled::val_labels(df_data[,i]) <- df_labels[[i]]
			} else unmatched <- c(unmatched, i)
		}
		if(length(unmatched)>0L) rlang::warn(c(x="Unable to find following Labels-variables in Dataset-variables:",
											   rlang::expr_text(unmatched)))

		col_select <- rlang::enquo(col_select)
		if(!rlang::quo_is_null(col_select)) {
			pos <- tidyselect::eval_select(col_select, df_data)
			df_data <- rlang::set_names(df_data[pos], names(pos))
		}
		dplyr::as_tibble(df_data)
	}


